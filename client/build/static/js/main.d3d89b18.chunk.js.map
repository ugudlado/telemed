{"version":3,"sources":["VideoComponent.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["VideoComponent","props","localMediaRef","createRef","remoteMediaRef","state","identity","roomName","roomNameErr","token","localMediaAvailable","hasJoinedRoom","joinRoom","bind","handleRoomNameChange","roomJoined","leaveRoom","detachTracks","detachParticipantTracks","e","target","value","this","setState","trim","console","log","connectOptions","name","previewTracks","tracks","Video","connect","then","error","alert","message","track","conatiner","newTrack","appendChild","attach","detach","forEach","detachedElement","remove","participant","container","attachTrack","current","detachTrack","Array","from","values","room","activeRoom","querySelector","attachParticipantTracks","localParticipant","participants","previewContainer","on","kind","stop","undefined","axios","get","results","data","disconnect","showLocalTrack","className","ref","joinOrLeaveRoomButton","type","onClick","placeholder","onChange","id","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.d3d89b18.chunk.js","sourcesContent":["import React, { Component, createRef, ChangeEvent } from 'react';\nimport Video, {  Room, ConnectOptions, LocalTrack, Participant,\n\t LocalVideoTrack, LocalAudioTrack, LocalVideoTrackPublication, LocalAudioTrackPublication\n\t} from 'twilio-video';\nimport axios from 'axios';\n\n\nexport interface Props {\n\n}\n\nexport interface State {\n    identity:string;\n    roomName:string;\n    roomNameErr:boolean;\n    previewTracks?:LocalTrack[] | MediaStreamTrack[];\n    localMediaAvailable:boolean;\n    hasJoinedRoom:boolean;\n    activeRoom?:Room;\n    token:string;\n}\n\n\n\nexport default class VideoComponent extends Component<Props, State> {\n    localMediaRef = createRef<HTMLDivElement>()\n    remoteMediaRef = createRef<HTMLDivElement>()\n\tconstructor(props: Props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\tidentity: '',\n\t\t\troomName: '',\n\t\t\troomNameErr: false, // Track error for room name TextField\n\t\t\ttoken:'',\n\t\t\tlocalMediaAvailable: false,\n\t\t\thasJoinedRoom: false\n\t\t};\n\t\tthis.joinRoom = this.joinRoom.bind(this);\n\t\tthis.handleRoomNameChange = this.handleRoomNameChange.bind(this);\n\t\tthis.roomJoined = this.roomJoined.bind(this);\n\t\tthis.leaveRoom = this.leaveRoom.bind(this);\n\t\tthis.detachTracks = this.detachTracks.bind(this);\n\t\tthis.detachParticipantTracks = this.detachParticipantTracks.bind(this);\n\t}\n\n\thandleRoomNameChange(e:ChangeEvent<HTMLInputElement>) {\n\t\tlet roomName = e.target.value;\n\t\tthis.setState({ roomName });\n\t}\n\n\tjoinRoom() {\n\t\tif (!this.state.roomName.trim()) {\n\t\t\tthis.setState({ roomNameErr: true });\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.log(\"Joining room '\" + this.state.roomName + \"'...\");\n        const connectOptions:ConnectOptions =\n         {\n            name: this.state.roomName\n\t\t};\n\n\t\tif (this.state.previewTracks) {\n\t\t\tconnectOptions.tracks = this.state.previewTracks;\n\t\t}\n\n\t\t// Join the Room with the token from the server and the\n\t\t// LocalParticipant's Tracks.\n\t\tVideo.connect(this.state.token, connectOptions).then(this.roomJoined, error => {\n\t\t\talert('Could not connect to Twilio: ' + error.message);\n\t\t});\n\t}\n\n\t//Unable to fix the type of track\n\tattachTrack(track: any,conatiner: Element) {\n\t\tlet newTrack : LocalVideoTrackPublication | LocalAudioTrackPublication  = track;\n\t\tconatiner.appendChild(newTrack.track.attach());\n\t}\n\n\tdetachTrack(track: any) {\n\t\tlet newTrack : LocalVideoTrackPublication | LocalAudioTrackPublication = track;\n\t\tnewTrack.track.detach().forEach((detachedElement : HTMLElement)=> {\n\t\t\tdetachedElement.remove();\n\t\t})\n\t}\n\n\n\t// Attaches a track to a specified DOM container\n\tattachParticipantTracks(participant: Participant, container: React.RefObject<HTMLDivElement>) {\n\t\tparticipant.tracks.forEach(track =>  this.attachTrack(track, container.current!))\n\t}\n\n\n\tdetachTracks(tracks: any[]) {\n\t\ttracks.forEach((track)=> {\n\t\t\tthis.detachTrack(track);\n\t\t});\n\t}\n\n\tdetachParticipantTracks(participant: Participant) {\n\t\tvar tracks = Array.from(participant.tracks.values());\n\t\tthis.detachTracks(tracks);\n\t}\n\n\troomJoined(room: Video.Room) { \n\t\t// Called when a participant joins a room\n\t\tconsole.log(\"Joined as '\" + this.state.identity + \"'\");\n\t\tthis.setState({\n\t\t\tactiveRoom: room,\n\t\t\tlocalMediaAvailable: true,\n\t\t\thasJoinedRoom: true\n\t\t});\n\n        // Attach LocalParticipant's Tracks, if not already attached.\n        \n\t\tif (!this.localMediaRef.current!.querySelector('video')) {\n\t\t\tthis.attachParticipantTracks(room.localParticipant, this.localMediaRef);\n\t\t}\n\n\t\t// Attach the Tracks of the Room's Participants.\n\t\troom.participants.forEach((participant) => {\n\t\t\tconsole.log(\"Already in Room: '\" + participant.identity + \"'\");\n\t\t\tvar previewContainer = this.remoteMediaRef;\n\t\t\tthis.attachParticipantTracks(participant, previewContainer);\n\t\t});\n\n\t\t// When a Participant joins the Room, log the event.\n\t\troom.on('participantConnected', (participant: { identity: string; }) => {\n\t\t\tconsole.log(\"Joining: '\" + participant.identity + \"'\");\n\t\t});\n\n\t\t// When a Participant adds a Track, attach it to the DOM.\n\t\troom.on('trackAdded', (track: { kind: string; }, participant: { identity: string; }) => {\n\t\t\tconsole.log(participant.identity + ' added track: ' + track.kind);\n\t\t\tvar previewContainer = this.remoteMediaRef.current!;\n\t\t\tthis.attachTrack(track, previewContainer);\n\t\t});\n\n\t\t// When a Participant removes a Track, detach it from the DOM.\n\t\troom.on('trackRemoved', (track: { kind: string; }, participant: { identity: string; }) => {\n\t\t\tconsole.log(participant.identity + ' removed track: ' + track.kind);\n\t\t\tthis.detachTracks([track]);\n\t\t});\n\n\t\t// When a Participant leaves the Room, detach its Tracks.\n\t\t\n\t\troom.on('participantDisconnected', (participant: Participant) => {\n\t\t\tconsole.log(\"Participant '\" + participant.identity + \"' left the room\");\n\t\t\tthis.detachParticipantTracks(participant);\n\t\t});\n\n\t\t// Once the LocalParticipant leaves the room, detach the Tracks\n\t\t// of all Participants, including that of the LocalParticipant.\n\t\troom.on('disconnected', () => {\n\t\t\tif (this.state.previewTracks) {\n\t\t\t\tthis.state.previewTracks!.forEach((track:any) =>{ \n\t\t\t\t\tlet videoTrack : LocalVideoTrack | LocalAudioTrack = track;\n\t\t\t\t\tvideoTrack.stop();\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.detachParticipantTracks(room.localParticipant);\n\t\t\troom.participants.forEach(this.detachParticipantTracks);\n\t\t\tthis.setState({ hasJoinedRoom: false, localMediaAvailable: false, activeRoom : undefined });\n\t\t});\n\t}\n\n\tcomponentDidMount() {\n\t\taxios.get('http://localhost:3001/token').then(results => {\n\t\t\tconst { identity, token } = results.data;\n\t\t\tthis.setState({ identity, token });\n\t\t});\n\t}\n\n\tleaveRoom() {\n\t\tthis.state.activeRoom!.disconnect();\n\t\tthis.setState({ hasJoinedRoom: false, localMediaAvailable: false });\n\t}\n\n\trender() {\n\t\t// Only show video track after user has joined a room\n\t\tlet showLocalTrack = this.state.localMediaAvailable ? (\n\t\t\t<div className=\"flex-item\">\n\t\t\t\t<div ref={this.localMediaRef} />\n\t\t\t</div>\n\t\t) : (\n\t\t\t''\n\t\t);\n\t\t// Hide 'Join Room' button if user has already joined a room.\n\t\tlet joinOrLeaveRoomButton = this.state.hasJoinedRoom ? (\n\t\t\t<input type=\"button\" value=\"Leave Room\" onClick={this.leaveRoom} />\n\t\t) : (\n\t\t\t<input type=\"button\" value=\"Join Room\" onClick={this.joinRoom} />\n\t\t);\n\t\treturn (\n\t\t\t\t\t<div className=\"flex-container\">\n\t\t\t\t\t\t{showLocalTrack}\n\t\t\t\t\t\t<div className=\"flex-item\">\n\t\t\t\t\t\t\t<input type=\"text\"\n\t\t\t\t\t\t\t\tplaceholder=\"room name\"\n\t\t\t\t\t\t\t\tonChange={this.handleRoomNameChange}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t<br />\n\t\t\t\t\t\t\t{joinOrLeaveRoomButton}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div className=\"flex-item\" ref={this.remoteMediaRef} id=\"remote-media\" />\n\t\t\t\t\t</div>\n\t\t);\n\t}\n}","import React from 'react';\nimport './App.css';\nimport VideoComponent from './VideoComponent';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <VideoComponent />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}